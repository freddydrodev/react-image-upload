{"version":3,"sources":["/Users/drofreddyjuniordiomande/.libs/npm/react-image-upload/dist/index.js","../src/index.tsx","../src/ReactImagePicker.tsx","../src/styles.ts","../src/uploadImage.ts"],"names":["__create","Object","create","__defProp","defineProperty","__getOwnPropDesc","getOwnPropertyDescriptor","__getOwnPropNames","getOwnPropertyNames","__getProtoOf","getPrototypeOf","__hasOwnProp","prototype","hasOwnProperty","__export","target","all","name","get","enumerable","__copyProps","to","from","except","desc","key","call","__toESM","mod","isNodeMode","__esModule","value","__toCommonJS","index_exports","ReactImagePicker","default","index_default","uploadImage","module","exports","React","require","import_dropzone","import_react_dropzone","import_react_use","import_react","Container","styled","display","flexDirection","border","DropzoneContainer","gap","padding","variants","isDisabled","true","cursor","false","Title","fontWeight","fontSize","lineHeight","textAlign","margin","marginTop","Description","Message","color","hasError","ImageGrid","maxHeight","gridTemplateColumns","gridColumns","defaultVariants","ImageContainer","position","width","height","borderRadius","overflow","objectFit","singleImage","maxWidth","DeleteButton","alignItems","justifyContent","boxShadow","backgroundColor","Overlay","zIndex","top","left","backdropFilter","transition","opacity","Dropzone","autoDiscover","getRuleValueAndMessage","rule","message","DEFAULT_RULES","maxSize","maxFiles","accepted","validateFile","file","rules","maxSizeMessage","acceptedMessage","size","toFixed","acceptedTypes","Array","isArray","map","type","toLowerCase","fileExtension","split","pop","fileType","isAccepted","some","startsWith","join","images","onImagesChanged","label","description","validate","deleteIcon","deleteBtnColor","deleteIconColor","renderImage","hideTitle","sectionGap","imageGap","imageGridCount","imageBorderRadius","style","className","props","maxFilesMessage","useState","files","setFiles","previewUrls","setPreviewUrls","validationMessage","setValidationMessage","isValidating","setIsValidating","generatePreviewUrls","useCallback","urls","URL","createObjectURL","extension","mimeType","fileWithMimeType","File","console","log","useMount","useEffect","forEach","url","revokeObjectURL","validateImages","result","error","Error","useDropzone","accept","reduce","acc","minSize","multiple","onDropRejected","fileRejections","event","errors","rejection","code","uniqueErrors","filter","index","self","indexOf","onDrop","acceptedFiles","length","validationErrors","processedFiles","newList","_file","getRootProps","getInputProps","reachedLimit","createElement","fileIsString","previewUrl","imgProps","src","alt","toString","onClick","e","_files","f","isString","stopPropagation","DeleteIcon","xmlns","fill","viewBox","d","import_storage","storage","isProd","path","_path","fullPath","storageRef","uploadTask","endsWith","slice","trim","ref","uploadBytesResumable","getDownloadURL","snapshot"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.tsx\nvar index_exports = {};\n__export(index_exports, {\n  ReactImagePicker: () => ReactImagePicker,\n  default: () => index_default,\n  uploadImage: () => uploadImage\n});\nmodule.exports = __toCommonJS(index_exports);\n\n// src/ReactImagePicker.tsx\nvar React = __toESM(require(\"react\"));\nvar import_dropzone = __toESM(require(\"dropzone\"));\nvar import_react_dropzone = require(\"react-dropzone\");\nvar import_react_use = require(\"react-use\");\n\n// src/styles.ts\nvar import_react = require(\"@stitches/react\");\nvar Container = (0, import_react.styled)(\"div\", {\n  display: \"flex\",\n  flexDirection: \"column\",\n  border: \"1px dashed #e0e0e0\"\n});\nvar DropzoneContainer = (0, import_react.styled)(\"div\", {\n  display: \"flex\",\n  flexDirection: \"column\",\n  gap: \"15px\",\n  border: 0,\n  padding: 0,\n  variants: {\n    isDisabled: {\n      true: { cursor: \"auto\" },\n      false: { cursor: \"pointer\" }\n    }\n  }\n});\nvar Title = (0, import_react.styled)(\"h2\", {\n  fontWeight: 700,\n  fontSize: \"2rem\",\n  lineHeight: \"1em\",\n  textAlign: \"center\",\n  margin: 0,\n  marginTop: \"15px\"\n});\nvar Description = (0, import_react.styled)(\"p\", {\n  fontWeight: 500,\n  fontSize: \"1rem\",\n  lineHeight: \"1.3em\",\n  textAlign: \"center\",\n  margin: 0\n});\nvar Message = (0, import_react.styled)(\"p\", {\n  fontSize: \"0.75rem\",\n  lineHeight: \"1.66\",\n  textAlign: \"center\",\n  margin: 0,\n  color: \"rgba(0, 0, 0, 0.5)\",\n  variants: {\n    hasError: {\n      true: { color: \"#d32f2f\", fontSize: \"0.8rem\" },\n      false: { color: \"inherit\" }\n    }\n  }\n});\nvar ImageGrid = (0, import_react.styled)(\"div\", {\n  display: \"grid\",\n  maxHeight: 380,\n  gridTemplateColumns: \"repeat(var(--grid-columns, 3), 1fr)\",\n  gap: \"var(--image-gap, 10px)\",\n  variants: {\n    gridColumns: {\n      value: {\n        \"--grid-columns\": \"var(--grid-columns-value, 3)\",\n        \"--image-gap\": \"var(--image-gap-value, 10px)\"\n      }\n    }\n  },\n  defaultVariants: {\n    gridColumns: \"value\"\n  }\n});\nvar ImageContainer = (0, import_react.styled)(\"div\", {\n  position: \"relative\",\n  width: \"100%\",\n  height: \"100%\",\n  borderRadius: \"var(--image-border-radius-value, 15px)\",\n  overflow: \"hidden\",\n  \"& img\": {\n    width: \"100%\",\n    height: \"100%\",\n    objectFit: \"cover\",\n    borderRadius: \"var(--image-border-radius-value, 15px)\"\n  },\n  variants: {\n    singleImage: {\n      true: {\n        maxWidth: \"400px\",\n        margin: \"0 auto\"\n      }\n    }\n  }\n});\nvar DeleteButton = (0, import_react.styled)(\"button\", {\n  width: 32,\n  height: 32,\n  borderRadius: \"50%\",\n  border: \"none\",\n  cursor: \"pointer\",\n  display: \"flex\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  padding: 0,\n  boxShadow: \"none\",\n  variants: {\n    color: {\n      default: {\n        backgroundColor: \"#f44336\",\n        color: \"#ffffff\"\n      }\n    }\n  }\n});\nvar Overlay = (0, import_react.styled)(\"div\", {\n  display: \"flex\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  width: \"100%\",\n  height: \"100%\",\n  borderRadius: \"15px\",\n  zIndex: 10,\n  position: \"absolute\",\n  top: 0,\n  left: 0,\n  backgroundColor: \"rgba(255,255,255,0)\",\n  backdropFilter: \"blur(0)\",\n  transition: \"all linear 0.25s\",\n  opacity: 0,\n  \"&:hover\": {\n    backgroundColor: \"rgba(255,255,255,0.25)\",\n    backdropFilter: \"blur(5px)\",\n    opacity: 1\n  }\n});\n\n// src/ReactImagePicker.tsx\nimport_dropzone.default.autoDiscover = false;\nvar getRuleValueAndMessage = (rule) => {\n  if (!rule) return { value: void 0 };\n  if (typeof rule === \"object\" && \"value\" in rule) {\n    return { value: rule.value, message: rule.message };\n  }\n  return { value: rule };\n};\nvar DEFAULT_RULES = {\n  maxSize: {\n    value: 5 * 1024 * 1024,\n    message: \"File size must be less than 5MB\"\n  },\n  maxFiles: { value: 1, message: \"Maximum 1 file allowed\" },\n  accepted: { value: \"image/*\", message: \"Only image files are accepted\" }\n};\nvar validateFile = (file, rules) => {\n  const { value: maxSize, message: maxSizeMessage } = getRuleValueAndMessage(\n    rules.maxSize\n  );\n  const { value: accepted, message: acceptedMessage } = getRuleValueAndMessage(\n    rules.accepted\n  );\n  if (maxSize && file.size > maxSize) {\n    return maxSizeMessage ?? `File size must be less than ${(maxSize / (1024 * 1024)).toFixed(1)}MB`;\n  }\n  if (accepted) {\n    const acceptedTypes = Array.isArray(accepted) ? accepted.map((type) => type.toLowerCase()) : [accepted.toLowerCase()];\n    const fileExtension = `.${file.name.split(\".\").pop()?.toLowerCase()}`;\n    const fileType = file.type.toLowerCase();\n    const isAccepted = acceptedTypes.some((type) => {\n      if (type === \"image/*\") {\n        return fileType.startsWith(\"image/\");\n      }\n      return type === fileExtension || type === fileType;\n    });\n    if (!isAccepted) {\n      return acceptedMessage ?? `File type not accepted. Accepted types: ${acceptedTypes.join(\", \")}`;\n    }\n  }\n  return null;\n};\nvar ReactImagePicker = ({\n  images = [],\n  onImagesChanged,\n  rules = DEFAULT_RULES,\n  label = \"Images\",\n  description,\n  validate,\n  deleteIcon,\n  deleteBtnColor = \"#f44336\",\n  deleteIconColor = \"#ffffff\",\n  renderImage,\n  hideTitle = false,\n  sectionGap = \"15px\",\n  imageGap = \"10px\",\n  imageGridCount = 3,\n  imageBorderRadius = \"15px\",\n  style,\n  className,\n  message,\n  hasError = false,\n  ...props\n}) => {\n  const { value: maxFiles, message: maxFilesMessage } = getRuleValueAndMessage(\n    rules.maxFiles\n  );\n  const { value: maxSize, message: maxSizeMessage } = getRuleValueAndMessage(\n    rules.maxSize\n  );\n  const { value: accepted } = getRuleValueAndMessage(rules.accepted);\n  const [files, setFiles] = React.useState(images);\n  const [previewUrls, setPreviewUrls] = React.useState([]);\n  const [validationMessage, setValidationMessage] = React.useState(null);\n  const [isValidating, setIsValidating] = React.useState(false);\n  const generatePreviewUrls = React.useCallback(() => {\n    const urls = files.map((file) => {\n      if (typeof file === \"string\") {\n        return file;\n      } else {\n        if (file.type && file.type.startsWith(\"image/\")) {\n          return URL.createObjectURL(file);\n        } else {\n          const extension = file.name.split(\".\").pop()?.toLowerCase();\n          let mimeType = \"image/jpeg\";\n          if (extension) {\n            switch (extension) {\n              case \"jpg\":\n              case \"jpeg\":\n                mimeType = \"image/jpeg\";\n                break;\n              case \"png\":\n                mimeType = \"image/png\";\n                break;\n              case \"gif\":\n                mimeType = \"image/gif\";\n                break;\n              case \"webp\":\n                mimeType = \"image/webp\";\n                break;\n              case \"svg\":\n                mimeType = \"image/svg+xml\";\n                break;\n              default:\n                mimeType = \"image/jpeg\";\n            }\n          }\n          const fileWithMimeType = new File([file], file.name, {\n            type: mimeType\n          });\n          return URL.createObjectURL(fileWithMimeType);\n        }\n      }\n    });\n    console.log(\"PREVIEW URLS =>\", urls);\n    setPreviewUrls(urls);\n  }, [files]);\n  (0, import_react_use.useMount)(() => {\n    generatePreviewUrls();\n  });\n  React.useEffect(() => {\n    generatePreviewUrls();\n  }, [files, generatePreviewUrls]);\n  React.useEffect(() => {\n    return () => {\n      previewUrls.forEach((url) => {\n        if (url.startsWith(\"blob:\")) {\n          URL.revokeObjectURL(url);\n        }\n      });\n    };\n  }, [previewUrls]);\n  React.useEffect(() => {\n    if (!validate) return;\n    const validateImages = async () => {\n      setIsValidating(true);\n      try {\n        const result = await validate(files);\n        setValidationMessage(result);\n      } catch (error) {\n        setValidationMessage(\n          error instanceof Error ? error.message : \"Validation failed\"\n        );\n      } finally {\n        setIsValidating(false);\n      }\n    };\n    validateImages();\n  }, [files, validate]);\n  const { getRootProps, getInputProps } = (0, import_react_dropzone.useDropzone)({\n    accept: accepted ? typeof accepted === \"string\" ? { [accepted]: [] } : accepted.reduce((acc, type) => {\n      let mimeType = type;\n      if (type.startsWith(\".\")) {\n        switch (type.toLowerCase()) {\n          case \".jpg\":\n          case \".jpeg\":\n            mimeType = \"image/jpeg\";\n            break;\n          case \".png\":\n            mimeType = \"image/png\";\n            break;\n          case \".gif\":\n            mimeType = \"image/gif\";\n            break;\n          case \".webp\":\n            mimeType = \"image/webp\";\n            break;\n          default:\n            mimeType = type;\n        }\n      }\n      return { ...acc, [mimeType]: [] };\n    }, {}) : { \"image/*\": [] },\n    minSize: 0,\n    maxSize,\n    maxFiles,\n    multiple: maxFiles === 1 ? false : true,\n    onDropRejected(fileRejections, event) {\n      const errors = fileRejections.map((rejection) => {\n        const file = rejection.file;\n        const error = rejection.errors[0];\n        if (error.code === \"file-too-large\") {\n          return maxSizeMessage ?? `${file.name} is too large. Maximum size is ${(maxSize / (1024 * 1024)).toFixed(1)}MB`;\n        }\n        if (error.code === \"file-invalid-type\") {\n          return `${file.name} has an invalid type`;\n        }\n        if (error.code === \"too-many-files\") {\n          return maxFilesMessage ?? `Maximum ${maxFiles} file${maxFiles === 1 ? \"\" : \"s\"} allowed`;\n        }\n        return error.message;\n      });\n      console.log(\"ERRORS REJECTED =>\", errors);\n      const uniqueErrors = errors.filter(\n        (error, index, self) => self.indexOf(error) === index\n      );\n      setValidationMessage(uniqueErrors.join(\"\\n\"));\n    },\n    onDrop: (acceptedFiles) => {\n      setValidationMessage(null);\n      if (maxFiles && files.length + acceptedFiles.length > maxFiles) {\n        setValidationMessage(\n          maxFilesMessage ?? `Maximum ${maxFiles} file${maxFiles === 1 ? \"\" : \"s\"} allowed`\n        );\n        return;\n      }\n      const validationErrors = acceptedFiles.map((file) => validateFile(file, rules)).filter((error) => error !== null);\n      console.log(\"ERRORS =>\", validationErrors);\n      if (validationErrors.length > 0) {\n        setValidationMessage(validationErrors.join(\"\\n\"));\n        return;\n      }\n      const processedFiles = acceptedFiles.map((file) => {\n        if (file.type && file.type.startsWith(\"image/\")) {\n          return file;\n        }\n        const extension = file.name.split(\".\").pop()?.toLowerCase();\n        let mimeType = \"image/jpeg\";\n        if (extension) {\n          switch (extension) {\n            case \"jpg\":\n            case \"jpeg\":\n              mimeType = \"image/jpeg\";\n              break;\n            case \"png\":\n              mimeType = \"image/png\";\n              break;\n            case \"gif\":\n              mimeType = \"image/gif\";\n              break;\n            case \"webp\":\n              mimeType = \"image/webp\";\n              break;\n            case \"svg\":\n              mimeType = \"image/svg+xml\";\n              break;\n            default:\n              mimeType = \"image/jpeg\";\n          }\n        }\n        return new File([file], file.name, { type: mimeType });\n      });\n      const newList = [\n        ...files,\n        ...processedFiles.filter(\n          (file) => files.filter((_file) => {\n            if (typeof _file === \"string\") return false;\n            return _file.name === file.name;\n          }).length === 0\n        )\n      ];\n      setFiles(newList);\n      if (onImagesChanged) {\n        onImagesChanged(newList);\n      }\n    }\n  });\n  React.useEffect(() => {\n    setFiles(images);\n  }, [images]);\n  const reachedLimit = maxFiles ? files.length >= maxFiles : false;\n  let size = 115;\n  console.log(files);\n  return /* @__PURE__ */ React.createElement(Container, { className, style }, /* @__PURE__ */ React.createElement(\n    DropzoneContainer,\n    {\n      ...!reachedLimit ? getRootProps({ className: \"dropzone\" }) : {},\n      isDisabled: reachedLimit\n    },\n    /* @__PURE__ */ React.createElement(\"input\", { ...getInputProps() }),\n    !hideTitle && /* @__PURE__ */ React.createElement(Title, null, label),\n    !reachedLimit && /* @__PURE__ */ React.createElement(Description, null, description ?? \"Vous pouvez ajouter les images en cliquant ici.\"),\n    files.length > 0 && /* @__PURE__ */ React.createElement(\n      ImageGrid,\n      {\n        gridColumns: \"value\",\n        style: {\n          \"--grid-columns-value\": imageGridCount,\n          \"--image-gap-value\": imageGap,\n          \"--image-border-radius-value\": imageBorderRadius\n        }\n      },\n      files.map((file, index) => {\n        const fileIsString = typeof file === \"string\";\n        const previewUrl = previewUrls[index] || (fileIsString ? file : \"\");\n        const imgProps = {\n          src: previewUrl ?? \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiNhYWEiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5JbWFnZSBQcmV2aWV3PC90ZXh0Pjwvc3ZnPg==\",\n          width: size,\n          height: size,\n          style: {\n            objectFit: \"cover\",\n            ...maxFiles === 1 ? {} : { width: \"100%\", height: \"100%\" }\n          },\n          alt: fileIsString ? file : file.name\n        };\n        return /* @__PURE__ */ React.createElement(\n          ImageContainer,\n          {\n            key: index.toString(),\n            singleImage: maxFiles === 1\n          },\n          renderImage ? renderImage(imgProps) : /* @__PURE__ */ React.createElement(\"img\", { ...imgProps }),\n          /* @__PURE__ */ React.createElement(Overlay, null, /* @__PURE__ */ React.createElement(\n            DeleteButton,\n            {\n              color: \"default\",\n              onClick: (e) => {\n                const _files = [\n                  ...files.filter((f) => {\n                    const isString = typeof f === \"string\";\n                    const name = isString ? f : f.name;\n                    return name !== (fileIsString ? file : file.name);\n                  })\n                ];\n                setFiles(_files);\n                onImagesChanged(_files);\n                e.stopPropagation();\n              }\n            },\n            deleteIcon ?? /* @__PURE__ */ React.createElement(DeleteIcon, null)\n          ))\n        );\n      })\n    ),\n    /* @__PURE__ */ React.createElement(Message, { hasError: !!validationMessage || hasError }, hasError ? message ?? \"An error occurred\" : isValidating ? \"Validating...\" : validationMessage ?? message ?? `Files up to ${(maxSize ?? 5 * 1024 * 1024) / (1024 * 1024)}MB, max ${maxFiles} files, accepted formats: ${Array.isArray(accepted) ? accepted.join(\", \") : accepted}`)\n  ));\n};\nvar DeleteIcon = () => /* @__PURE__ */ React.createElement(\n  \"svg\",\n  {\n    xmlns: \"http://www.w3.org/2000/svg\",\n    width: \"16\",\n    height: \"16\",\n    fill: \"currentColor\",\n    className: \"bi bi-trash\",\n    viewBox: \"0 0 16 16\"\n  },\n  /* @__PURE__ */ React.createElement(\"path\", { d: \"M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0z\" }),\n  /* @__PURE__ */ React.createElement(\"path\", { d: \"M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4zM2.5 3h11V2h-11z\" })\n);\n\n// src/uploadImage.ts\nvar import_storage = require(\"firebase/storage\");\nvar uploadImage = async ({\n  file,\n  storage,\n  isProd = false,\n  path = \"Images\"\n}) => {\n  if (typeof file === \"string\") return file;\n  let _path = path.endsWith(\"/\") ? path.slice(0, -1) : path;\n  if (!_path.trim().length) _path = \"Images\";\n  const fullPath = `${isProd ? \"\" : \"DEV/\"}${_path}/${file.name}`;\n  const storageRef = (0, import_storage.ref)(storage, fullPath);\n  const uploadTask = (0, import_storage.uploadBytesResumable)(storageRef, file);\n  await uploadTask;\n  const url = await (0, import_storage.getDownloadURL)(uploadTask.snapshot.ref);\n  return url;\n};\n\n// src/index.tsx\nvar index_default = ReactImagePicker;\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  ReactImagePicker,\n  uploadImage\n});\n","import { ReactImagePicker } from \"./ReactImagePicker\";\n\nexport * from \"./types\";\n\nexport * from \"./uploadImage\";\n\nexport default ReactImagePicker;\n\nexport * from \"./ReactImagePicker\";\n","import * as React from \"react\";\nimport Dropzone from \"dropzone\";\nimport { useDropzone } from \"react-dropzone\";\nimport { useMount } from \"react-use\";\nimport {\n  renderImageType,\n  ReactImagePickerProps,\n  FileValidationRules,\n  RuleWithMessage,\n} from \"./types\";\nimport {\n  Container,\n  DropzoneContainer,\n  Title,\n  Description,\n  ImageGrid,\n  ImageContainer,\n  DeleteButton,\n  Overlay,\n  Message,\n} from \"./styles\";\n\nDropzone.autoDiscover = false;\n\n/**\n * Helper function to get rule value and message\n */\nconst getRuleValueAndMessage = <T,>(\n  rule: RuleWithMessage<T> | undefined\n): { value: T | undefined; message?: string } => {\n  if (!rule) return { value: undefined };\n  if (typeof rule === \"object\" && \"value\" in rule) {\n    return { value: rule.value, message: rule.message };\n  }\n  return { value: rule };\n};\n\n/**\n * Default validation rules\n */\nconst DEFAULT_RULES: FileValidationRules = {\n  maxSize: {\n    value: 5 * 1024 * 1024,\n    message: \"File size must be less than 5MB\",\n  },\n  maxFiles: { value: 1, message: \"Maximum 1 file allowed\" },\n  accepted: { value: \"image/*\", message: \"Only image files are accepted\" },\n};\n\n/**\n * Validates a file against the provided rules\n */\nconst validateFile = (\n  file: File,\n  rules: FileValidationRules\n): string | null => {\n  const { value: maxSize, message: maxSizeMessage } = getRuleValueAndMessage(\n    rules.maxSize\n  );\n  const { value: accepted, message: acceptedMessage } = getRuleValueAndMessage(\n    rules.accepted\n  );\n\n  // Check file size\n  if (maxSize && file.size > maxSize) {\n    return (\n      maxSizeMessage ??\n      `File size must be less than ${(maxSize / (1024 * 1024)).toFixed(1)}MB`\n    );\n  }\n\n  // Check file type\n  if (accepted) {\n    const acceptedTypes = Array.isArray(accepted)\n      ? accepted.map((type) => type.toLowerCase())\n      : [accepted.toLowerCase()];\n\n    const fileExtension = `.${file.name.split(\".\").pop()?.toLowerCase()}`;\n    const fileType = file.type.toLowerCase();\n\n    const isAccepted = acceptedTypes.some((type) => {\n      if (type === \"image/*\") {\n        return fileType.startsWith(\"image/\");\n      }\n      return type === fileExtension || type === fileType;\n    });\n\n    if (!isAccepted) {\n      return (\n        acceptedMessage ??\n        `File type not accepted. Accepted types: ${acceptedTypes.join(\", \")}`\n      );\n    }\n  }\n\n  return null;\n};\n\n/**\n * A React component for selecting and displaying images using a drag-and-drop interface.\n *\n * @param {Object} props - The component props.\n * @param {(File | string)[]} [props.images] - Initial images to display.\n * @param {(images: (File | string)[]) => void} props.onImagesChanged - Callback triggered when the image list changes.\n * @param {FileValidationRules} [props.rules] - Validation rules for the images.\n * @param {string} [props.label] - The label displayed for the image picker.\n * @param {string} [props.description] - Additional text to describe the image picker.\n * @param {boolean} [props.validate] - Flag to indicate if the image picker is in a valid state.\n * @param {React.ReactNode} [props.deleteIcon] - Custom delete icon to be used.\n * @param {string} [props.deleteBtnColor=\"#f44336\"] - Color of the delete button.\n * @param {string} [props.deleteIconColor=\"#ffffff\"] - Color of the delete icon.\n * @param {(props: renderImageType) => React.ReactNode} [props.renderImage] - Custom component to render images.\n * @param {boolean} [props.hideTitle=false] - Flag to hide the title.\n * @param {string} [props.sectionGap=\"15px\"] - Gap between sections (ex: title, description, images, etc...) in pixels.\n * @param {string} [props.imageGap=\"10px\"] - Gap between images in pixels.\n * @param {number} [props.imageGridCount=3] - The number of images to display in the grid.\n * @param {string} [props.imageBorderRadius=\"15px\"] - The border radius of the images.\n * @returns {JSX.Element} The ReactImagePicker component.\n */\nexport const ReactImagePicker: React.FC<ReactImagePickerProps> = ({\n  images = [],\n  onImagesChanged,\n  rules = DEFAULT_RULES,\n  label = \"Images\",\n  description,\n  validate,\n  deleteIcon,\n  deleteBtnColor = \"#f44336\",\n  deleteIconColor = \"#ffffff\",\n  renderImage,\n  hideTitle = false,\n  sectionGap = \"15px\",\n  imageGap = \"10px\",\n  imageGridCount = 3,\n  imageBorderRadius = \"15px\",\n  style,\n  className,\n  message,\n  hasError = false,\n  ...props\n}) => {\n  const { value: maxFiles, message: maxFilesMessage } = getRuleValueAndMessage(\n    rules.maxFiles\n  );\n  const { value: maxSize, message: maxSizeMessage } = getRuleValueAndMessage(\n    rules.maxSize\n  );\n  const { value: accepted } = getRuleValueAndMessage(rules.accepted);\n\n  /**\n   * IMAGES SELECTED BY THE USER\n   */\n  const [files, setFiles] = React.useState<(File | string)[]>(images);\n\n  const [previewUrls, setPreviewUrls] = React.useState<string[]>([]);\n\n  const [validationMessage, setValidationMessage] = React.useState<\n    string | null\n  >(null);\n\n  const [isValidating, setIsValidating] = React.useState(false);\n\n  /**\n   * Generate preview URLs for files\n   */\n  const generatePreviewUrls = React.useCallback(() => {\n    const urls = files.map((file) => {\n      if (typeof file === \"string\") {\n        return file;\n      } else {\n        // Check if the file has a valid MIME type\n        if (file.type && file.type.startsWith(\"image/\")) {\n          return URL.createObjectURL(file);\n        } else {\n          // If the file doesn't have a valid MIME type, try to determine it from the extension\n          const extension = file.name.split(\".\").pop()?.toLowerCase();\n          let mimeType = \"image/jpeg\"; // Default to jpeg\n\n          if (extension) {\n            switch (extension) {\n              case \"jpg\":\n              case \"jpeg\":\n                mimeType = \"image/jpeg\";\n                break;\n              case \"png\":\n                mimeType = \"image/png\";\n                break;\n              case \"gif\":\n                mimeType = \"image/gif\";\n                break;\n              case \"webp\":\n                mimeType = \"image/webp\";\n                break;\n              case \"svg\":\n                mimeType = \"image/svg+xml\";\n                break;\n              default:\n                mimeType = \"image/jpeg\"; // Default fallback\n            }\n          }\n\n          // Create a new File object with the correct MIME type\n          const fileWithMimeType = new File([file], file.name, {\n            type: mimeType,\n          });\n          return URL.createObjectURL(fileWithMimeType);\n        }\n      }\n    });\n\n    console.log(\"PREVIEW URLS =>\", urls);\n    setPreviewUrls(urls);\n  }, [files]);\n\n  /**\n   * Generate preview URLs on mount and when files change\n   */\n  useMount(() => {\n    generatePreviewUrls();\n  });\n\n  React.useEffect(() => {\n    generatePreviewUrls();\n  }, [files, generatePreviewUrls]);\n\n  /**\n   * Clean up preview URLs when component unmounts or files change\n   */\n  React.useEffect(() => {\n    return () => {\n      // Revoke all object URLs to prevent memory leaks\n      previewUrls.forEach((url) => {\n        if (url.startsWith(\"blob:\")) {\n          URL.revokeObjectURL(url);\n        }\n      });\n    };\n  }, [previewUrls]);\n\n  /**\n   * Handle validation\n   */\n  React.useEffect(() => {\n    if (!validate) return;\n\n    const validateImages = async () => {\n      setIsValidating(true);\n      try {\n        const result = await validate(files);\n        setValidationMessage(result);\n      } catch (error) {\n        setValidationMessage(\n          error instanceof Error ? error.message : \"Validation failed\"\n        );\n      } finally {\n        setIsValidating(false);\n      }\n    };\n\n    validateImages();\n  }, [files, validate]);\n\n  const { getRootProps, getInputProps } = useDropzone({\n    accept: accepted\n      ? typeof accepted === \"string\"\n        ? { [accepted]: [] }\n        : accepted.reduce((acc, type) => {\n            // Convert file extensions to MIME types\n            let mimeType: string = type;\n            if (type.startsWith(\".\")) {\n              switch (type.toLowerCase()) {\n                case \".jpg\":\n                case \".jpeg\":\n                  mimeType = \"image/jpeg\";\n                  break;\n                case \".png\":\n                  mimeType = \"image/png\";\n                  break;\n                case \".gif\":\n                  mimeType = \"image/gif\";\n                  break;\n                case \".webp\":\n                  mimeType = \"image/webp\";\n                  break;\n                default:\n                  // Keep the original type if it's not recognized\n                  mimeType = type;\n              }\n            }\n            return { ...acc, [mimeType]: [] };\n          }, {})\n      : { \"image/*\": [] },\n    minSize: 0,\n    maxSize: maxSize,\n    maxFiles: maxFiles,\n    multiple: maxFiles === 1 ? false : true,\n    onDropRejected(fileRejections, event) {\n      const errors = fileRejections.map((rejection) => {\n        const file = rejection.file;\n        const error = rejection.errors[0];\n\n        if (error.code === \"file-too-large\") {\n          return (\n            maxSizeMessage ??\n            `${file.name} is too large. Maximum size is ${(\n              maxSize! /\n              (1024 * 1024)\n            ).toFixed(1)}MB`\n          );\n        }\n\n        if (error.code === \"file-invalid-type\") {\n          return `${file.name} has an invalid type`;\n        }\n\n        if (error.code === \"too-many-files\") {\n          return (\n            maxFilesMessage ??\n            `Maximum ${maxFiles} file${maxFiles === 1 ? \"\" : \"s\"} allowed`\n          );\n        }\n\n        return error.message;\n      });\n\n      console.log(\"ERRORS REJECTED =>\", errors);\n\n      const uniqueErrors = errors.filter(\n        (error, index, self) => self.indexOf(error) === index\n      );\n\n      setValidationMessage(uniqueErrors.join(\"\\n\"));\n    },\n    onDrop: (acceptedFiles) => {\n      setValidationMessage(null);\n\n      // Check if adding these files would exceed the maximum\n      if (maxFiles && files.length + acceptedFiles.length > maxFiles) {\n        setValidationMessage(\n          maxFilesMessage ??\n            `Maximum ${maxFiles} file${maxFiles === 1 ? \"\" : \"s\"} allowed`\n        );\n        return;\n      }\n\n      // Validate each file against rules\n      const validationErrors = acceptedFiles\n        .map((file) => validateFile(file, rules))\n        .filter((error): error is string => error !== null);\n\n      console.log(\"ERRORS =>\", validationErrors);\n\n      if (validationErrors.length > 0) {\n        setValidationMessage(validationErrors.join(\"\\n\"));\n        return;\n      }\n\n      // Process files to ensure they have proper MIME types\n      const processedFiles = acceptedFiles.map((file) => {\n        // If the file already has a valid MIME type, use it as is\n        if (file.type && file.type.startsWith(\"image/\")) {\n          return file;\n        }\n\n        // Otherwise, determine the MIME type from the extension\n        const extension = file.name.split(\".\").pop()?.toLowerCase();\n        let mimeType = \"image/jpeg\"; // Default to jpeg\n\n        if (extension) {\n          switch (extension) {\n            case \"jpg\":\n            case \"jpeg\":\n              mimeType = \"image/jpeg\";\n              break;\n            case \"png\":\n              mimeType = \"image/png\";\n              break;\n            case \"gif\":\n              mimeType = \"image/gif\";\n              break;\n            case \"webp\":\n              mimeType = \"image/webp\";\n              break;\n            case \"svg\":\n              mimeType = \"image/svg+xml\";\n              break;\n            default:\n              mimeType = \"image/jpeg\"; // Default fallback\n          }\n        }\n\n        // Create a new File object with the correct MIME type\n        return new File([file], file.name, { type: mimeType });\n      });\n\n      const newList = [\n        ...files,\n        ...processedFiles.filter(\n          (file) =>\n            files.filter((_file: File | string) => {\n              if (typeof _file === \"string\") return false;\n              return _file.name === file.name;\n            }).length === 0\n        ),\n      ];\n\n      /**\n       * CHANGE THE LOCAL VERSION OF THE IMAGES\n       */\n      setFiles(newList);\n\n      /**\n       * CHANGE THE PARENT VERSION TOO\n       */\n      if (onImagesChanged) {\n        onImagesChanged(newList);\n      }\n    },\n  });\n\n  /**\n   * Handle initial File objects\n   */\n  React.useEffect(() => {\n    setFiles(images);\n  }, [images]);\n\n  const reachedLimit = maxFiles ? files.length >= maxFiles : false;\n\n  let size = 115;\n\n  console.log(files);\n\n  return (\n    <Container className={className} style={style}>\n      <DropzoneContainer\n        {...(!reachedLimit ? getRootProps({ className: \"dropzone\" }) : {})}\n        isDisabled={reachedLimit}\n      >\n        <input {...getInputProps()} />\n\n        {!hideTitle && <Title>{label}</Title>}\n\n        {!reachedLimit && (\n          <Description>\n            {description ?? \"Vous pouvez ajouter les images en cliquant ici.\"}\n          </Description>\n        )}\n\n        {files.length > 0 && (\n          <ImageGrid\n            gridColumns=\"value\"\n            style={\n              {\n                \"--grid-columns-value\": imageGridCount,\n                \"--image-gap-value\": imageGap,\n                \"--image-border-radius-value\": imageBorderRadius,\n              } as React.CSSProperties\n            }\n          >\n            {files.map((file, index) => {\n              const fileIsString = typeof file === \"string\";\n              const previewUrl =\n                previewUrls[index] || (fileIsString ? file : \"\");\n\n              const imgProps: renderImageType = {\n                src:\n                  previewUrl ??\n                  \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiNhYWEiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5JbWFnZSBQcmV2aWV3PC90ZXh0Pjwvc3ZnPg==\",\n                width: size,\n                height: size,\n                style: {\n                  objectFit: \"cover\",\n                  ...(maxFiles === 1 ? {} : { width: \"100%\", height: \"100%\" }),\n                },\n                alt: fileIsString ? file : file.name,\n              };\n\n              return (\n                <ImageContainer\n                  key={index.toString()}\n                  singleImage={maxFiles === 1}\n                >\n                  {renderImage ? renderImage(imgProps) : <img {...imgProps} />}\n                  <Overlay>\n                    <DeleteButton\n                      color=\"default\"\n                      onClick={(e) => {\n                        const _files = [\n                          ...files.filter((f) => {\n                            const isString = typeof f === \"string\";\n                            const name = isString\n                              ? (f as string)\n                              : (f as File).name;\n\n                            return name !== (fileIsString ? file : file.name);\n                          }),\n                        ];\n\n                        setFiles(_files);\n\n                        onImagesChanged(_files);\n\n                        e.stopPropagation();\n                      }}\n                    >\n                      {deleteIcon ?? <DeleteIcon />}\n                    </DeleteButton>\n                  </Overlay>\n                </ImageContainer>\n              );\n            })}\n          </ImageGrid>\n        )}\n\n        <Message hasError={!!validationMessage || hasError}>\n          {hasError\n            ? message ?? \"An error occurred\"\n            : isValidating\n            ? \"Validating...\"\n            : validationMessage ??\n              message ??\n              `Files up to ${\n                (maxSize ?? 5 * 1024 * 1024) / (1024 * 1024)\n              }MB, max ${maxFiles} files, accepted formats: ${\n                Array.isArray(accepted) ? accepted.join(\", \") : accepted\n              }`}\n        </Message>\n      </DropzoneContainer>\n    </Container>\n  );\n};\n\nconst DeleteIcon = () => (\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    width=\"16\"\n    height=\"16\"\n    fill=\"currentColor\"\n    className=\"bi bi-trash\"\n    viewBox=\"0 0 16 16\"\n  >\n    <path d=\"M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0z\" />\n    <path d=\"M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4zM2.5 3h11V2h-11z\" />\n  </svg>\n);\n","import { styled } from \"@stitches/react\";\n\nexport const Container = styled(\"div\", {\n  display: \"flex\",\n  flexDirection: \"column\",\n  border: \"1px dashed #e0e0e0\",\n});\n\nexport const DropzoneContainer = styled(\"div\", {\n  display: \"flex\",\n  flexDirection: \"column\",\n  gap: \"15px\",\n  border: 0,\n  padding: 0,\n  variants: {\n    isDisabled: {\n      true: { cursor: \"auto\" },\n      false: { cursor: \"pointer\" },\n    },\n  },\n});\n\nexport const Title = styled(\"h2\", {\n  fontWeight: 700,\n  fontSize: \"2rem\",\n  lineHeight: \"1em\",\n  textAlign: \"center\",\n  margin: 0,\n  marginTop: \"15px\",\n});\n\nexport const Description = styled(\"p\", {\n  fontWeight: 500,\n  fontSize: \"1rem\",\n  lineHeight: \"1.3em\",\n  textAlign: \"center\",\n  margin: 0,\n});\n\nexport const Message = styled(\"p\", {\n  fontSize: \"0.75rem\",\n  lineHeight: \"1.66\",\n  textAlign: \"center\",\n  margin: 0,\n  color: \"rgba(0, 0, 0, 0.5)\",\n  variants: {\n    hasError: {\n      true: { color: \"#d32f2f\", fontSize: \"0.8rem\" },\n      false: { color: \"inherit\" },\n    },\n  },\n});\n\nexport const ImageGrid = styled(\"div\", {\n  display: \"grid\",\n  maxHeight: 380,\n  gridTemplateColumns: \"repeat(var(--grid-columns, 3), 1fr)\",\n  gap: \"var(--image-gap, 10px)\",\n  variants: {\n    gridColumns: {\n      value: {\n        \"--grid-columns\": \"var(--grid-columns-value, 3)\",\n        \"--image-gap\": \"var(--image-gap-value, 10px)\",\n      },\n    },\n  },\n  defaultVariants: {\n    gridColumns: \"value\",\n  },\n});\n\nexport const ImageContainer = styled(\"div\", {\n  position: \"relative\",\n  width: \"100%\",\n  height: \"100%\",\n  borderRadius: \"var(--image-border-radius-value, 15px)\",\n  overflow: \"hidden\",\n  \"& img\": {\n    width: \"100%\",\n    height: \"100%\",\n    objectFit: \"cover\",\n    borderRadius: \"var(--image-border-radius-value, 15px)\",\n  },\n  variants: {\n    singleImage: {\n      true: {\n        maxWidth: \"400px\",\n        margin: \"0 auto\",\n      },\n    },\n  },\n});\n\nexport const DeleteButton = styled(\"button\", {\n  width: 32,\n  height: 32,\n  borderRadius: \"50%\",\n  border: \"none\",\n  cursor: \"pointer\",\n  display: \"flex\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  padding: 0,\n  boxShadow: \"none\",\n  variants: {\n    color: {\n      default: {\n        backgroundColor: \"#f44336\",\n        color: \"#ffffff\",\n      },\n    },\n  },\n});\n\nexport const Overlay = styled(\"div\", {\n  display: \"flex\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  width: \"100%\",\n  height: \"100%\",\n  borderRadius: \"15px\",\n  zIndex: 10,\n  position: \"absolute\",\n  top: 0,\n  left: 0,\n  backgroundColor: \"rgba(255,255,255,0)\",\n  backdropFilter: \"blur(0)\",\n  transition: \"all linear 0.25s\",\n  opacity: 0,\n  \"&:hover\": {\n    backgroundColor: \"rgba(255,255,255,0.25)\",\n    backdropFilter: \"blur(5px)\",\n    opacity: 1,\n  },\n});\n","import { getDownloadURL, ref, uploadBytesResumable } from \"firebase/storage\";\nimport { UploadImageType } from \"./types\";\n\n/**\n * Uploads a file to Firebase Storage and returns the download URL.\n * @param {File|string} file The file to upload, or the URL of the file\n * @param {FirebaseStorage} storage The Firebase Storage instance\n * @param {boolean} [isProd=false] Whether or not this is a production upload\n * @param {string} [path='Images'] The path to upload the file to\n * @returns {Promise<string>} The download URL of the uploaded file\n */\nexport const uploadImage: UploadImageType = async ({\n  file,\n  storage,\n  isProd = false,\n  path = \"Images\",\n}): Promise<string> => {\n  if (typeof file === \"string\") return file;\n\n  // The path is the full path including the filename, so we'll remove the trailing slash\n  let _path = path.endsWith(\"/\") ? path.slice(0, -1) : path;\n\n  // If the path is empty, we'll default to \"Images\"\n  if (!_path.trim().length) _path = \"Images\";\n\n  // The full path is the path plus the filename\n  const fullPath = `${isProd ? \"\" : \"DEV/\"}${_path}/${file.name}`;\n\n  // Create a reference to the file\n  const storageRef = ref(storage, fullPath);\n\n  // Start the upload\n  const uploadTask = uploadBytesResumable(storageRef, file);\n\n  // Wait for the upload to finish\n  await uploadTask;\n\n  // Get the download URL\n  const url = await getDownloadURL(uploadTask.snapshot.ref);\n\n  // Return the download URL\n  return url;\n};\n"]}